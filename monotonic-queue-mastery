Absolutely â€” hereâ€™s your **Monotonic Queue Mastery Sheet** just like the sliding window and monotonic stack ones.

Monotonic queue problems mostly involve maintaining:

âœ… Max/Min in a sliding window
âœ… Stream processing (online)
âœ… Dynamic window queries
âœ… Deques used as monotonic structures

These often overlap heavily with sliding window but have their own pattern.

---

# ðŸ§  MONOTONIC QUEUE MASTER ROADMAP

This is organized into **6 phases**:

* Phase 1 â€” Foundation
* Phase 2 â€” Window Tracking
* Phase 3 â€” Sliding Window Max/Min
* Phase 4 â€” Variants & Counting
* Phase 5 â€” Multi-Deque Hybrid
* Phase 6 â€” Interview Hard / Mastery

The problems come from the official **Monotonic Queue LeetCode list**:

ðŸ”— [https://leetcode.com/problem-list/monotonic-queue/](https://leetcode.com/problem-list/monotonic-queue/)

---

## ðŸŸ¢ PHASE 1 â€” FOUNDATION (Understand Deque Pattern)

Learn the core idea:

> A monotonic queue maintains increasing or decreasing order using a deque
> This allows O(1) queries for current max/min in a sliding window.

Solve these first:

1. **LC 239** â€” Sliding Window Maximum
2. **LC 862** â€” Shortest Subarray with Sum at Least K
3. **LC 845** â€” Longest Mountain in Array (partially dq)
4. **LC 239** *(redo with boundary pointers & pointers only solution)*

**What you master here:**

* Simple deque push/pop logic
* Maintaining head/tail ordering
* Using deque of indices

---

## ðŸŸ¡ PHASE 2 â€” WINDOW MAX / WINDOW MIN

Now solidify with variations:

5. **LC 2090** â€” K Radius Subarray Averages (sliding min prefix segment)
6. **LC 275** â€” H-Index II (binary + monotonic properties mixed)
7. **LC 2162** â€” Closest Divide in Matrix (window + dq inside)

**What you focus on:**

* Adjust deque when window slides
* Population/depuration of deque
* Maintaining only useful candidates

---

## ðŸ”µ PHASE 3 â€” COUNTING / Query Output

Now problems where you output array results:

8. **LC 862** â€” Redo for counting min length
9. **LC 239** â€” Output sliding max per window
10. **LC 2389** â€” Longest Subarray With Limit
11. **LC 1111** â€” Maximum Nesting Depth (deque min around boundary)

**What you master:**

* Output per index
* Queue trimming
* Window correctness

---

## ðŸŸ£ PHASE 4 â€” DYNAMIC / VARIABLE WINDOW + Deque

These combine monotonic queue plus shrinkable window:

12. **LC 1000** â€” Minimum Cost to Merge Stones (not obvious but deque helps)
13. **LC 2085** â€” Count Common Words With One Occurrence (encoded)
14. **LC 1854** â€” Maximum Population Year (no window but counting variant)
15. **LC 662** â€” Maximum Width of Vertical Area (missing monotonic queue but conceptual connection)

*The list itself includes placeholder problems that arenâ€™t strictly monotonic queue â€” but many sliding window max/min apply.*

---

## ðŸ”´ PHASE 5 â€” HARD / DEQUE ADVANCED

Now harder hybrid problems:

16. **LC 862** â€” Redo with prefix sums and deque for minimum length
17. **LC 239** â€” Redo optimized index logic
18. **LC 1695** â€” Maximum Erasure Value *(needs both freq + window)*
19. **LC 1004** â€” Max Consecutive Ones III *(window with deque helpful for cost tracking)*

These force you to use:

* Deque to enforce constraints
* Window + pointer logic
* Dynamic min/max tracking

---

## ðŸŸ¤ PHASE 6 â€” MASTER LEVEL

These are tough because the monotonic queue is part of a larger solution:

20. **LC 2140** â€” Solving Questions With Brainpower *(stack + queue combo)*
21. **LC 1696** â€” Jump Game VI *(priority queue but deque resembles pattern)*
22. **LC 2090** â€” Multiple radius validations
23. **LC 1705** â€” Maximum Number of Eaten Apples *(greedy + deque)*

These are *meta problems* where monotonic queue is a tool, not the whole solution.

---

# ðŸ§  PRACTICE RULES

## Must Learn Deque Operations

### For max queue:

```
Add new value v:
    while back not empty and back < v:
        pop back
    push back

Remove old index i:
    if front == i:
        pop front

Current max = arr[front]
```

---

## Must Dry-Run for all deque problems

Write each step like:

```
i=0 â†’ push 1 â†’ deque [0]
i=1 â†’ push 3 â†’ pop smaller (1), deque [1]
...
```

---

# ðŸ“… WEEKLY PRACTICE PLAN (2 weeks)

| Day    | Focus                                |
| ------ | ------------------------------------ |
| Day 1  | Sliding Window Max basics            |
| Day 2  | Understanding deque push/pop         |
| Day 3  | Variants with window min             |
| Day 4  | Output window results                |
| Day 5  | Dynamic window with deque            |
| Day 6  | Hybrid problems                      |
| Day 7  | Practice 3 random deque problems     |
| Day 8  | Interview simulations                |
| Day 9  | Redo previously solved with dry-runs |
| Day 10 | Hard / mixed problems                |
| Day 11 | Mock interview session               |
| Day 12 | Edge case optimization               |
| Day 13 | Large input optimization             |
| Day 14 | Patterns re-write from memory        |

---

# ðŸ§  COMMON PATTERNS TO INTERNALIZE

### 1ï¸âƒ£ Sliding Window Max

* Always store indices in deque
* Values in deque are in descending order
* Front always holds index of the current max

---

### 2ï¸âƒ£ Sliding Window Min

* Same as max but ascending order

---

### 3ï¸âƒ£ Online Queries

Examples: Stock Span

* Data arrives in real time

---

### 4ï¸âƒ£ Boundary Detection

Monotonic queue often answers:

```
nearest greater
nearest smaller
window range
```

---

# ðŸ“ QUICK Problem Categorization Cheat Sheet

| Type                     | Example |
| ------------------------ | ------- |
| Window Max               | LC 239  |
| Min window length        | LC 862  |
| Window with constraint   | LC 1004 |
| Deque + dynamic pointers | LC 1695 |

---

# ðŸ“Œ NOTES

ðŸ’¡ **Easy Mistake:**
Treat normal sliding window as monotonic queue â€” not all problems require deque.

ðŸ’¡ **Always ask:**

> Do I need O(1) max/min queries for every sliding window move?

If YES â†’ Monotonic queue

---

## Want NEXT? ðŸš€

Choose one:

1. A **50-problem challenge sheet** combining monotonic queue with sliding window and monotonic stack
2. A **pattern cheat sheet PDF template**
3. Daily **timed practice plan** (30 days)
4. Mock interview questions + answer patterns

Just tell me which ðŸ”¥ you want next!
